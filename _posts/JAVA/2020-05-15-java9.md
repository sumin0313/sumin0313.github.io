---
layout: post
title: "[JAVA] 메소드 오버라이딩" 
categories: JAVA
tags: [JAVA]
---

## 메소드 오버라이딩(Method Overriding)
  
같은 이름을 가지고 있으나 다른 기능을 할 때 메소드 **오버로딩(overloading)** 이라고 칭한 바 있다. 메소드 오버라이딩은 메소드를 **재정의** 하는 것을 의미한다. 
슈퍼 클래스를 상속한 서브 클래스는 슈퍼 클래스 메소드의 이름, 매개변수 타입 및 개수, 리턴 타입 등 모든 것을 동일하게 작성한다. 메소드 무시하기, 덮어쓰기로 번역되기도 한다. 

![image1](/assets/images/JavaImages/74.png)


오버라이딩 시에는 서브 클래스에 오버라이딩 된 메소드가 무조건 실행되는 **동적 바인딩**이 발생한다.

![image2](/assets/images/JavaImages/75.png)

위와 같은 사례에서 서브 클래스가 메소드를 호출하는 과정은 다음과 같다.

`Shape` 클래스를 상속받은 `Line` 클래스의 객체 `line`은 `Shape`과 `Line` 클래스의 멤버 및 메소드에 모두 접근 가능하다. 
그러나 `draw()` 메소드를 호출할 때는 오버라이딩 된 `Line` 클래스 쪽 메소드가 호출된다.

![image3](/assets/images/JavaImages/76.png)


`Line` 클래스로 생성된 객체가 `Shape` 클래스로 업캐스팅 되었다고 해도 마찬가지다. 
본디 업캐스팅 된 객체는 슈퍼 클래스의 객체로서 인식되지만, 이 경우엔 동적 바인딩에 의해 오버라이딩 된 서브 클래스 쪽 메소드가 호출된다.

![image4](/assets/images/JavaImages/77.png)




## 동적 바인딩

동적 바인딩은 실행할 메소드를 실행 시, 즉 **런타임 시**에 결정한다. 항상 오버라이딩 메소드가 호출된다는 점을 잊으면 안된다. 

![image5](/assets/images/JavaImages/78.png)



## 오버라이딩의 목적

오버라이딩의 가장 큰 목적은 여러개의 형태를 갖게 하는, 즉 **다형성의 실현**에 있다. 객체 지향의 특징 중 하나로, 오버로딩의 목적도 이와 동일하다. 

오버라이딩은 슈퍼 클래스에 선언된 메소드를 각 서브 클래스들이 자신만의 내용으로 새로 구현하는 것을 가능하게 한다. 상속을 통해 하나의 인터페이스에 서로 다른 내용을 구현하는 것이다.
위에서 살펴보았던 상속 관계도에서 `Line` 클래스의 `draw()`는 선을 그리고, `Circle` 클래스의 `draw()`는 원을 그리며, `Rect` 클래스의 `draw()`는 사각형을 그리는 것을 통해 다형성이 어떻게 구현되었는지 확인할 수 있었다.

또한 동적 바인딩을 통해 실행 중 다형성(실행시간 다형성)을 실현한다. 오버로딩은 컴파일 중 다형성을 실현하는 컴파일 타임 다형성을 실현한다는 점에서 둘은 차이가 있다.


|비교요소|메소드 오버로딩|메소드 오버라이딩|
|:---:|---|---|
|선언|같은 클래스나 상속 관계에서 동일한 이름의 메소드 **중복 작성**|서브 클래스에서 슈퍼 클래스에 있는 메소드와 동일한 이름의 메소드 **재작성**|
|관계|동일한 클래스 내 혹은 상속 관계|상속 관계|
|목적|이름이 같은 여러 개의 메소드를 중복 작성하여 사용의 편리성 향상. 다형성 실현.|슈퍼 클래스에 구현된 메소드를 무시하고 서브 클래스에서 새로운 기능의 메소드를 재정의하고자 함. 다형성 실현|
|조건|메소드 이름은 반드시 동일하고, 매개변수 타입이나 개수가 달라야 함.|메소드의 이름, 매개변수 타입과 개수, 리턴 타입이 **모두 동일**하여야 함.|
|바인딩|정적 바인딩. 호출될 메소드는 컴파일 시에 결정.|동적 바인딩. 실행 시간에 오버라이딩된 메소드를 찾아 호출.|

다음 코드는 메소드 오버라이딩으로 다형성을 실현시키는 과정이다.

![image6](/assets/images/JavaImages/80.png)

메인 메소드의 코드를 보면 `Shape` 클래스를 상속받은 `Line` 클래스의 객체를 생성, `paint` 메소드의 매개변수로 넘겨주는 것을 알 수 있다. 
`paint` 메소드의 `p.draw()`는 매개변수로 받은 `p`객체의 `draw()` 메소드를 호출하는데,
`line` 레퍼런스가 `Shape`과 `Line` 클래스 모두를 가리키고 있으나 오버라이딩 된 `Line` 클래스의 `draw()`만 호출된다(동적바인딩).

`paint(new Shape());` 코드를 제외한 다른 코드 또한 마찬가지로 슈퍼 클래스의 `draw()`가 아닌 오버라이딩 된 자신의 `draw()`를 실행함으로써 동적 바인딩이 이루어지고 다형성이 실현된다.

![image7](/assets/images/JavaImages/81.png)



## 오버라이딩의 활용

오버라이딩은 **연결 리스트(linked list)** 를 만드는데 사용될 수 있다. 연결 리스트는 이름 그대로 데이터들을 일렬로 묶어놓은 것을 의미한다. 아래의 코드를 살펴보자.   

![image8](/assets/images/JavaImages/82.png)


위의 코드는 `Shape` 클래스를 슈퍼 클래스로 두고 `Line`, `Rect`, `Circle` 클래스를 서브 클래스로 둔 후, 각각의 서브 클래스에서 `draw()` 메소드를 오버라이딩 하였다.
그리고 `paint` 메소드를 통해 메인 메소드에서 각각의 `draw()`를 호출하도록 만들었다.

이제 아래의 코드를 살펴보자.

![image9](/assets/images/JavaImages/83.png)


이는 앞선 `Line`, `Rect`, `Circle` 클래스를 활용하여 연결 리스트를 구연한 코드이다. 우선 `Shape` 클래스의 레퍼런스인 `start`, `last`, `obj`를 생성한다.
`start`는 연결 리스트의 첫 번째 객체에 대한 레퍼런스를 가지고, `last`는 연결 리스트의 마지막 객체에 대한 레퍼런스를 가지며, `obj`는 `last`가 리스트의 마지막 객체를 가리킬 수 있도록 레퍼런스를 공유하는 역할을 한다.

다시 말해, `start` 레퍼런스의 위치는 처음에 고정되지만 `obj`는 새로 생성된 객체(=마지막 객체가 갱신됨)의 레퍼런스를 가지고 있다가, `last`와 해당 레퍼런스 값을 공유하는 역할을 수행한다고 보면 된다.

조금 더 자세히 살펴보자.


 우선 `start`, `last` 레퍼런스가 `Line` 객체를 가리키도록 한다. 현재는 하나의 객체뿐이므로 `Line` 객체는 일렬로 늘어선 연결 리스트에서 가장 처음이자 마지막에 위치하기 때문이다. 
 
 ```java
 start = new Line(); //Line 객체 연결
 last = start;
 ```
 
그 다음, `Rect` 객체를 `Line` 객체 바로 다음에 둘 것이기 때문에 `obj`에 `Rect` 클래스 객체의 레퍼런스를 저장한다.

```java
 obj = new Rect();
```

`obj`가 `Rect` 객체를 가리키게 되었다면 레퍼런스 값을 `last`에게 넘겨주어야 한다. 그런데, 한 가지 의문점이 생긴다. 
우리는 '연결' 리스트를 만드는 중이다. `start`와 `last` 가 어느 객체를 가리키는지 알 수 있다고 해서 그 객체들이 '연결'되었다고 볼 수 있는가? 
이 의문을 해결하기 위해 `last.next`에 `obj` 값을 넣어 두 객체를 연결시켜주는 것이다. 말하자면 각 객체 내 슈퍼 클래스 멤버가 다른 객체의 레퍼런스를 가짐으로서 연결고리 역할을 하는 것이다.

```java
 last.next = obj; //Rect 객체에 연결
 last = obj;
```

만약 `last.next = obj;` 코드가 없다면 각각의 객체는 그저 독립적으로 존재하게 된다. 그것은 '연결'되었다고 볼 수 없는 것이다.
따라서 `Shape`의 멤버에게 다음 객체의 레퍼런스를 갖게 함으로써 아래와 같이 '연결' 형태를 갖춘 것이다.

![image10](/assets/images/JavaImages/87.png)


이와 같은 행위를 반복하다보면 결국 일렬로 연결된 리스트를 얻게 된다. 총 4개의 객체를 연결시켜 만들어진 이 리스트는 첫 번째 객체의 슈퍼 클래스가 두 번째 객체 레퍼런스를 가지게 되고, 
두 번째 객체의 슈퍼 클래스가 세 번째 객체의 레퍼런스를 가진다. 마지막에 위치한 객체는 기존에 `null`로 초기화 되어있던 `last.next`에 변화가 없어 그대로 `null` 값을 가진다.

때문에 아래의 코드를 실행하게 되면, `p`가 가리키는 객체의 `draw()`를 출력되고, 다음 객체의 레퍼런스가 저장되어 있던 `next` 값이 `p`에 저장되어 
다음 `draw()`를 출력한다. 이는 `p` 값이 `null`인 마지막 객체까지 반복된다. 

![image11](/assets/images/JavaImages/88.png)


## super 키워드

`super` 키워드는 슈퍼 클래스의 멤버에 접근할 때 사용되는 레퍼런스로 *서브 클래스에서만 사용*된다. 
슈퍼 클래스의 메소드를 호출하는 역할을 하며 컴파일러는 이를 정적 바인딩으로 처리한다. 오버라이딩을 통해 동적 바인딩이 이루어지지 않도록 하기 위해서는 해당 키워드가 필수적이다.


![image8](/assets/images/JavaImages/89.png)





