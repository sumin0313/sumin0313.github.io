---
layout: post
title: "[JAVA] 상속" 
categories: JAVA
tags: [JAVA]
---

## 상속 
  
상속은 객체 지향의 대표적인 특징 중 하나로 부모 클래스에 만들어진 필드, 메소드를 자식 클래스가 물려받는 것을 의미한다. 
때문에 중복된 코드의 작성이 불필요하고 클래스의 재사용과 확장이 용이하며 계층적 분류를 통해 클래스의 관리가 용이해진다는 장점이 있다.

![image1](/assets/images/JavaImages/58.png)

그러나 클래스의 *다중 상속은 지원하지 않으며* 상속 횟수는 **무제한**이다. 


## 상속 선언

부모 클래스는 **슈퍼 클래스**, 자식 클래스는 **서브 클래스**라고 부르며 상속받았다는 의미로 `extends` 키워드를 사용한다. 
자식 클래스는 부모 클래스에게서 상속받은 클래스에 추가적인 코드를 덧붙이는 것을 기본으로 하므로 부모 클래스를 확장한다는 개념을 가지고 있기 때문이다.
 
아래 코드는 상속 선언의 예시이다.

![image2](/assets/images/JavaImages/59.png)



## 상속과 접근 지정자

클래스와 멤버에 대한 접근 지정자를 살펴본 적 있다. 상속 관계에서 주의할 접근 지정자는 `private`과 `protected` 이다.
슈퍼 클래스의 `private` 멤버는 다른 모든 클래스에 접근을 불허하며, `protected` 멤버는 같은 패키지 내 클래스의 접근만 허용하지만 
만약 서브 클래스가 다른 패키지에 있다면 해당 멤버에 접근이 가능하다.

![image3](/assets/images/JavaImages/60.png)




## 상속과 호출

`new`에 의해 서브 클래스의 객체가 생성될 때, 슈퍼클래스의 생성자와 서브 클래스의 생성자가 모두 실행된다. 
서브 클래스의 생성자가 먼저 호출되고 호출된 생성자는 실행 전 슈퍼 클래스의 생성자를 호출하게 된다. 
그러나 먼저 호출되었던 서브 클래스의 생성자와는 달리 *실행은 슈퍼 클래스의 생성자 먼저* 이루어지며 그 후 서브 클래스의 생성자가 실행된다. 

![image4](/assets/images/JavaImages/61.png)


상속관계에서 슈퍼 클래스와 서브 클래스는 각각 여러 생성자를 작성 가능하다. 이때, `super()`를 이용해 서브 클래스 생성자에서 슈퍼 클래스 생성자를 하나 선택하게 되는데 
만약 생성자를 선택하지 않는 경우 컴파일러가 자동으로 슈퍼 클래스의 기본 생성자를 선택한다. 

![image5](/assets/images/JavaImages/62.png)


만약 아래와 같이 슈퍼 클래스에 기본 생성자가 없다면 컴파일러에 의해 오류가 발생한다.

![image6](/assets/images/JavaImages/63.png)


서브 클래스에 매개변수를 가진 생성자가 슈퍼 클래스의 생성자를 선택하지 않는 경우에도 기본 생성자를 선택한다.

![image7](/assets/images/JavaImages/64.png)


따라서 아래와 같이 `super()`를 이용하여 명시적으로 슈퍼 클래스 생성자를 선택하는 것이 좋다. 이때, 슈퍼 클래스의 생성자를 선택하는 코드는 
반드시 서브 클래스 생성자 코드의 **가장 첫 라인**에 와야 한다.

![image8](/assets/images/JavaImages/65.png)  


상속이란 슈퍼 클래스를 기반으로 코드를 확장시킬 때 사용하는 것인 만큼, *슈퍼 클래스의 생성자를 호출하는 것이 필수*임을 기억해야 한다.





## 업캐스팅(upcasting)

서브클래스의 객체는 슈퍼 클래스의 멤버를 모두 가지고 있으며 슈퍼 클래스의 객체로 취급할 수 있다. 업캐스팅이란 서브 클래스의 객체를 **슈퍼 클래스 타입으로 변환**하는 것을 의미한다. 

![image9](/assets/images/JavaImages/66.png) 


업캐스팅 된 객체 내에는 슈퍼 클래스의 멤버만 접근 가능하다. 다시 말해, 업캐스팅 된 서브 클래스의 객체는 **슈퍼 클래스로 취급**되어 더이상 서브 클래스의 객체로서 기능하지 않게 된다.

![image10](/assets/images/JavaImages/67.png) 


그러나 슈퍼 클래스는 여러 서브 클래스에 상속되기 때문에 업캐스팅 된 레퍼런스로는 객체의 타입 판단이 어렵다. 아래의 상속관계를 살펴보자.

![image11](/assets/images/JavaImages/68.png)

위와 같은 상속 관계는 아래와 같은 업캐스팅이 가능한데 이때, `print(p)` 를 호출하면 `p`가 어떤 객체를 가리키는지 알 수 없다.

![image12](/assets/images/JavaImages/69.png)


이때, `instanceof` 연산자를 통해 레퍼런스가 가리키는 객체의 타입을 식별할 수 있다.

![image13](/assets/images/JavaImages/70.png)



따라서 `jee`는 `Person`, `Student` 타입이고 `kim`은 `Person`, `Researcher`, `Professor` 타입, `lee`는 `Person`, `Researcher` 타입이다. 

![image14](/assets/images/JavaImages/71.png)



## 다운캐스팅(downcasting)

반대로 다운캐스팅은 *슈퍼 클래스의 객체를 서브 클래스 타입으로 변환*하는 것을 의미한다. 이때, 개발자의 **명시적 타입 변환**이 필요하다. 아래는 위의 코드를 바탕으로 다운캐스팅한 사례이다.

![image15](/assets/images/JavaImages/72.png)


업캐스팅하여 슈퍼 클래스의 객체가 된 `Student` 객체는 다운캐스팅을 거쳐 다시 서브 클래스의 객체가 된다. 따라서 서브 클래스 레퍼런스 `s`를 이용해 접근할 수 있게 된다.

![image16](/assets/images/JavaImages/73.png)













